%% I.K. 5-6-24 
% Called by function: simpleCurationMouseWrapper
function maskStruct = simpleCurationSessionWrapper ...
    ( axs ...
    , mname ...
    , sessionIdx ...
    , sessionData ...
    , simpleCandidateMask ...
    , previousCuration ...
    )

nChannels = numel(simpleCandidateMask);

p = IkUtils.getParams();

if ~any(simpleCandidateMask)
    warning ...
        ( "No simple spike candidates found in session %d for %s" ...
        , sessionIdx ...
        , mname ...
        );

    if IkUtils.do_prompt_yes_or_no(sprintf("There are %d out of %d neurons in the simple candidate mask. Overwrite simple spike candidates mask and inspect all channels?",sum(simpleCandidateMask), length(sessionData.neuron)))
        simpleCandidateMask = true(1,nChannels).';
    elseif isempty(sessionData.neuron) 
        maskStruct = struct ...
            ( simple = simpleCandidateMask ...
            , exemplary = false(1, nChannels) ... %IK change % repmat(false, 1, nChannels) ...
            , modulation = {cell(1,nChannels)} ...
            );

        for i = 1 : length(maskStruct.modulation)
            if maskStruct.simple(i) == 0
                maskStruct.modulation{i} = struct ...
                    ( cs_facilitation = false ...
                    , us_facilitation = false ...
                    , cs_suppression = false ...
                    , us_suppression = false ...
                    );
            end
        end
        return
    end
end

if isempty(previousCuration)
    if (sum(simpleCandidateMask) < nChannels) && IkUtils.do_prompt_yes_or_no(sprintf("There are %d out of %d neurons in the simple candidate mask. Overwrite simple spike candidates mask and inspect all channels?",sum(simpleCandidateMask), length(sessionData.neuron)))
        simpleCandidateMask = true(1,nChannels).';
    end
    masks = struct ...
        ( simple = simpleCandidateMask ...
        , exemplary = false(1, nChannels) ... % IK change % repmat(false, 1, nChannels) ...          
        , modulation = {cell(1,nChannels)} ... %repmat({default_modulation_struct}, 1, nChannels) ... % IK change %{cell(1,nChannels)} ...
        );
    for i = 1 : length(masks.modulation)
        if masks.simple(i) == 0
            masks.modulation{i} = struct ...
                ( cs_facilitation = false ...
                , us_facilitation = false ...
                , cs_suppression = false ...
                , us_suppression = false ...
                );
        end
    end
else
    masks = previousCuration;
end

%     maskStructs = repmat ...
%         ( struct ...
%             ( simple = false ...
%             , exemplary
%             ) ...
%         , nChannels, 1 ...
%         );
%             , exemplary = false ...

if sum(masks.simple) < length(masks.simple) && IkUtils.do_prompt_yes_or_no(sprintf("Hide non-simple neurons?"))
    simpleCandidateMask = masks.simple; % IK change % find(simpleCandidateMask);
else
    simpleCandidateMask = true(1,nChannels).';
end
simpleCandidates = find(simpleCandidateMask);

if isempty(simpleCandidates)
    uiState = UiState ...
        ( channelIdx = 0 ...
        , masks = masks ...
        , reachedBottom = true ...
        , reachedTop = false ...
        );
    maskStruct = uiState.masks;
    return
end


%     simpleIdx = simpleCandidates(1);

% TODO: implement masks for marking neurons as exemplary
choiceMap = ...
    { "toggle simple selection"     , @toggleSimple ...
    ; "override modulation"         , @promptModulationMask ...
    ; "mark as exemplary"           , @toggleExemplaryNeuron ...
    ; "debug"                       , @debug ...
    ; "prev"                        , mkPrevFn(simpleCandidateMask) ...
    ; "next"                        , mkNextFn(simpleCandidateMask) ...
    };
quit = false;

uiState = UiState ...
    ( channelIdx = simpleCandidates(1) ... 
    , masks = masks ...
    , reachedBottom = false ...
    , reachedTop = false ...
    );

while ~quit

    choice = "";

    while not( uiState.reachedBottom || uiState.reachedTop )% || uiState.exit )

        %% Compute histogram statistics and estimate modulation
        modulationRanges = IkUtils.getParams().sspkRanges;

        histStats = struct ...
            ( cs = computePsthStats ...
            ( sessionData.neuron(uiState.channelIdx).RasterXY_cs_filtered ...
            , modulationRanges.cs ...
            , p.psthRanges.cs_full ...
            ) ... % IK change removed prior
            , us = computePsthStats ...
            ( sessionData.neuron(uiState.channelIdx).RasterXY_cs_filtered ... % IK change. Changed this to cs because we are only plotting the CS_aligned and the modulationranges for the us are also written as cs_aligned.
            , modulationRanges.us ...
            , p.psthRanges.cs_full ... % IK change, same here
            ) ...
            );

        histModThres = IkUtils.getParams().histogramModulationThreshold_sspks;               

        if isempty(uiState.masks.modulation{uiState.channelIdx})
            %             if isempty(modulationEstimates{uiState.channelIdx})
            %                 modulationEstimates{uiState.channelIdx} =
            uiState.masks.modulation{uiState.channelIdx} = struct ...
                ( cs_facilitation = histStats.cs.modulation > 2.5*histStats.cs.basefreqSD ... %histModThres ... %false ...histStats.cs.maxAmp > histModThres ...  % IK change, changed from false to the logical. % IK change, removed prior
                , cs_suppression = histStats.cs.modulation < -2.5*histStats.cs.basefreqSD ...
                , us_facilitation = histStats.us.modulation > 2.5*histStats.us.basefreqSD ... %false ...histStats.us.maxAmp > histModThres ...
                , us_suppression = histStats.us.modulation < -2.5*histStats.us.basefreqSD ... %(histStats.us.maxAmp/histModThres.binWidth - histStats.us.baseline/histModThres.us.binWidth - histStats.us.meanAboveBaseline/histModThres.us.binWidth) > histModThres ...
                );
        end


        %             modulation = struct ...
        %                 ( cs = histStats.cs.maxAmp > histModThres ... % IK
        %                 change, removed prior
        %                 , us = histStats.us.maxAmp > histModThres ...
        %                 );

        %% Visualize channel data
        % sessionData = IkUtils.writeDataGood(sessionData);

        viewChannelSpikes ...
            ( axs.neuronAxs ...
            , sessionData.neuron(uiState.channelIdx) ...
            , sessionData.neuron(uiState.channelIdx).irc_trueID ...
            , sessionIdx ...
            , mname ...
            , histStats ...
            , histRanges = modulationRanges ...
            );

        %             maskStructs(simpleIdx) = ...
        %                 curateSimpleChannel ...
        %                     ( axs ...
        %                     , sessionData.neuron(simpleIdx) ...
        %                     , sessionData.KSTrueID(simpleIdx) ...
        %                     , mname ...
        %                     , sessionIdx ...
        %                     );

        %% Check for and visualize previous curation

        if ~uiState.masks.simple(uiState.channelIdx)
            arrayfun ...
                ( @(ax) fadeAxes(ax, color = [0.7048 0.5418 0.5418]) ...
                , axs.neuronAxs ...
                )
            fprintf("\n\nThis channel is currently not in the simple channel selection.\n\n")
        end

        if uiState.masks.exemplary(uiState.channelIdx)
            axs.neuronAxs(1).Parent.Color = getColors().exemplary;
        else
            axs.neuronAxs(1).Parent.Color = [.98 .98 .98];
        end

        %% CURATE

        fprintf("\nThis neuron has the following modulation properties:\n")
        modulation = uiState.masks.modulation{uiState.channelIdx};
        modStr = sprintf...
            ( "cs facilitation: %d\n" ... % IK change, removed prior
            + "cs suppression: %d\n" ...
            + "us facilitation: %d\n" ...
            + "us suppression: %d\n\n" ...
            , modulation.cs_facilitation ... % IK change, removed prior
            , modulation.cs_suppression ...
            , modulation.us_facilitation ...
            , modulation.us_suppression ...
            );
        %             IkUtils.printIndented(modStr);
        fprintf(modStr); % IK change

        [choice, choiceIdx] = IkUtils.do_prompt_select_option([choiceMap{:,1}]); % IK change

        fn = choiceMap{choiceIdx, 2};

        try
            uiState = fn(uiState);
        catch err
            warning ...
                ( "Caught error during execution of `%s`:\n%s\n" ...
                + "\terror: %s\n" ...
                + "\tfunction: %s\n" ...
                + "\tline: %d\n" ...
                , choice ...
                , fprintf(string(err.message)) ... % IK change
                , sprintf("%s: %s", err.identifier, err.message) ...
                , err.stack(1).name ...
                , err.stack(1).line ...
                )

            fprintf("\nStarting debug mode.\n\n")
            keyboard
        end

    end

    if uiState.reachedBottom
        warning("Already at first neuron of session")
        uiState.reachedBottom = false;
    end
    if uiState.reachedTop
        quit = IkUtils.do_prompt_yes_or_no ...
            ( "Last neuron of session reached.    Finish curating this session now?" ... % IK change
            );
        if ~quit
            uiState.reachedTop = false;
        end
    end

end

%     maskStruct = struct ...
%         ( simple = [maskStructs.simple] ...
%         );
maskStruct = uiState.masks;

end

function uiState = toggleExemplaryNeuron(uiState)
arguments
    uiState(1,1) UiState
end

idx = uiState.channelIdx;
exemplaryStatus = uiState.masks.exemplary(idx);
uiState.masks.exemplary(idx) = not(exemplaryStatus);

if uiState.masks.exemplary(idx)
    uiState.masks.simple(idx) = true;
end

end

function uiState = promptModulationMask(uiState)

modulationCombinations = ...
    { "none"            , [] ...
    ; "CS facilitation only"         , ["cs_facilitation"] ...
    ; "US facilitation only"         , ["us_facilitation"] ...
    ; "CS suppression only"          , ["cs_suppression"] ...
    ; "US suppression only"          , ["us_suppression"] ...
    ; "CS and US facilitation"       , ["cs_facilitation", "us_facilitation"] ... % IK change, removed prior
    ; "CS facilitation and US suppression"  , ["cs_facilitation", "us_suppression"] ...
    ; "CS suppression and US facilitation"  , ["cs_suppression", "us_facilitation"] ...
    ; "CS and US suppression"               , ["cs_suppression", "us_suppression"] ...
    };

[~, idx] = IkUtils.do_prompt_select_option([modulationCombinations{:,1}]);

newMask = modulationStruct(modulationCombinations{idx, 2});

uiState.masks.modulation{uiState.channelIdx} = newMask;

    function result = modulationStruct(events)

        result = struct ...
            ( cs_facilitation = false ... % IK change, removed prior
            , us_facilitation = false ...
            , cs_suppression = false ...
            , us_suppression = false ...
            );

        for event = events(:)'
            result.(event) = true;
        end

    end

end

function uiState = toggleSimple(uiState)
arguments
    uiState(1,1) UiState
end

idx = uiState.channelIdx;
selectionStatus = uiState.masks.simple(idx);
uiState.masks.simple(idx) = not(selectionStatus);

if not(uiState.masks.simple(idx))
    uiState.masks.exemplary(idx) = false;
end
end

function uiState = debug(uiState)
keyboard
end

%% Navigation Utilities

function bool = hasPrev(candidateMask, idx)
bool = idx > find(candidateMask, 1);
end

function bool = hasNext(candidateMask, idx)
bool = idx < find(candidateMask, 1, 'last');
end

function fn = mkPrevFn(candidateMask)

    function uiState = prevChannel(uiState)
        currentIdx = uiState.channelIdx;
        if hasPrev(candidateMask, currentIdx)
            prevIdx = find(candidateMask(1:(currentIdx-1)), 1, 'last');
        else
            prevIdx = currentIdx;
            uiState.reachedBottom = true;
        end
        uiState.channelIdx = prevIdx;
    end

fn = @prevChannel;
end

function fn = mkNextFn(candidateMask)

    function uiState = nextChannel(uiState)
        currentIdx = uiState.channelIdx;
        if hasNext(candidateMask, currentIdx)
            nextIdx = currentIdx + find(candidateMask(currentIdx+1:end, 1), 1);
        else
            nextIdx = currentIdx;
            uiState.reachedTop = true;
        end
        uiState.channelIdx = nextIdx;
    end

fn = @nextChannel;
end