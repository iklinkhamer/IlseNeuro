% Curate complex channels and their modulation masks for a single session.

% Copyright 2023 NarainLab
% Erasmus Medical Center, Rotterdam, The Netherlands
% v2023-01-05
%
% TODO: write results to disk for each session separately to allow for quick,
% easy and safe switching between sessions.
%
% complexCurationSessionWrapper : SessionID -> CurationResult
function [maskStruct, histStats] = complexPriorCurationSessionWrapper ...
                                        ( axs ...
                                        , mname ...
                                        , sessionIdx ...
                                        , sessionData ...
                                        , putativeComplexMask ...
                                        , simpleMask ...
                                        , previousCuration ...
                                        )
                                            
    nChannels = numel(putativeComplexMask);
    
    fprintf("\nSession has %d putative complex channels.\n", sum(putativeComplexMask))
    
    simpleChannels = find(simpleMask);
    
    SessionConstants = struct ...
        ( mname = mname ...
        , sessionIdx = sessionIdx ...
        , ksTrueIds = sessionData.KSTrueID ...
        , axs = axs ...
        );
    
    p = getParams();
    
    if isempty(previousCuration)
        maskStruct = struct ...
            ( exemplary = repmat(false, 1, nChannels) ...
            , complex = putativeComplexMask ...
            , modulation = {cell(1,nChannels)} ...
            );
        warning ...
            ( "This function was copied ad-hoc for recuration of prior-related " ...
            + "complex spike channels. However, no previous curation for this " ...
            + "session could be found, so this function returns immediately." ...
            )
        return
    else
        masks = struct ...
            ( exemplary = previousCuration.exemplary ...
            , complex = previousCuration.complex ...
            , modulation = {previousCuration.modulation} ...
            );
    end
    
    if numel(unique(sessionData.trGroups)) > 2
        warning ...
            ( "This function was copied ad-hoc for recuration of prior-related " ...
            + "complex spike channels in DELTA sessions. Since the current " ...
            + "session is uniform, this function returns immediately." ...
            )
        maskStruct = masks;
        return
    end
    
    if isnumeric(masks.modulation) && isempty(masks.modulation)
        warning("Previous curation is empty, returning now.")
        maskStruct = masks;
        return
    end
    
    isPriorModulating = @(x) isstruct(x) && isfield(x, 'prior') && x.prior;
    prevPriorModulatingMask = cellfun ...
        ( isPriorModulating ...
        , masks.modulation ...
        );
    
    candidatesMask = putativeComplexMask(:) ...
                    & prevPriorModulatingMask(:) ...
                    & previousCuration.complex(:);
    
    candidates = find(candidatesMask);
    
    fprintf ...
        ( "Previous curation indicates %d prior-modulating complex " ...
        + "channels in this session.\n" ...
        , numel(candidates) ...
        );
    if isempty(candidates)
        maskStruct = masks;
        return
    end
    
    uiState = UiState ...
        ( channelIdx = candidates(1) ...
        , masks = masks ...
        , reachedBottom = false ...
        , reachedTop = false ...
        , finishSession = false ...
        );
    
    choiceMap = ...
        { "toggle complex selection"    , @toggleComplex ...
        ; "override modulation"         , @promptModulationMask ...
        ; "mark as exemplary"           , @toggleExemplaryNeuron ...
        ; "save figure"                 , @saveFigure ...
        ; "debug"                       , @debug ...
        ; "prev"                        , mkPrevFn(candidatesMask) ...
        ; "next"                        , mkNextFn(candidatesMask) ...
        ; "finish session"              , @finishSession ...
        };
%         ; "exit without saving"         , @exit ...
    quit = false;
    
    while ~quit
    
    choice = "";
    
        while not( uiState.reachedBottom || uiState.reachedTop || uiState.finishSession )
            
            %% Get corresponding simple spike channel (if any)
            % TODO: find a more descriptive function name than `crosscorrelation`
            simpleIdx = crossCorrelation(sessionData, simpleChannels, uiState.channelIdx);
            
            %% Compute histogram statistics and estimate modulation
            cspkRanges = p.cspkRanges;
    
            histStats = struct ...
                ( cs = computePsthStats ...
                    ( sessionData.neuron(uiState.channelIdx).RasterXY_cs ...
                    , cspkRanges.cs ...
                    , p.psthRanges.cs_full ...
                    ) ... % IK change. Removed prior
                , us = computePsthStats ...
                    ( sessionData.neuron(uiState.channelIdx).RasterXY_us ...
                    , cspkRanges.us ...
                    , p.psthRanges.us_full ...
                    ) ...
                );
            
            histModThres = p.histogramModulationThreshold;
            
            getEventRangeLen = @(eventStats) ...
                eventStats.searchRange.max - eventStats.searchRange.min;
            estimateModulation = @(eventStats) ...
                eventStats.maxAmp >= 4*eventStats.baseline ...
                && eventStats.maxAmp >= histModThres ...
                && eventStats.sd <= p.sd_thres * getEventRangeLen(eventStats);
            
            modulationEstimate = struct ...
                ( cs = estimateModulation(histStats.cs) ... % IK change. removed prior
                , us = estimateModulation(histStats.us) ...
                );            
            
%             modulationEstimate = struct ...
%                 ( cs = histStats.cs.maxAmp >= 3*histStats.cs.baseline ...
%                         && histStats.cs.maxAmp >= histModThres ...
%                         && histStats.cs.sd <= p.sd_thres ...      % IK change. removed prior
%                 , us = histStats.us.maxAmp >= 3*histStats.us.baseline ...
%                             && histStats.us.maxAmp >= histModThres ...
%                             && histStats.us.sd <= p.sd_thres ...
%                 );
            
            if isempty(uiState.masks.modulation{uiState.channelIdx})
                uiState.masks.modulation{uiState.channelIdx} = modulationEstimate;
            end
                
            %% Visualize channel data
            viewComplexChannel ...
                ( axs ...
                , sessionData.neuron(uiState.channelIdx) ...
                , sessionData.KSTrueID(uiState.channelIdx) ...
                , histStats ...
                , sessionData.neuron(simpleIdx) ...
                , sessionData.KSTrueID(simpleIdx) ...
                , mname ...
                , sessionIdx ...
                , trialTypes = sessionData.trGroups ...
                );
            
            %% Check for and visualize previous curation
            
            if ~uiState.masks.complex(uiState.channelIdx)
                arrayfun ...
                    ( @(ax) fadeAxes(ax, color = [0.7048 0.5418 0.5418]) ...
                    , axs.neuronAxs ...
                    );
                fprintf("\n\nThis channel is currently not in the complex channel selection.\n\n")
            end
            
            if uiState.masks.exemplary(uiState.channelIdx)
                axs.neuronAxs(1).Parent.Color = getColors().exemplary;
            else
                axs.neuronAxs(1).Parent.Color = [.98 .98 .98];
            end
            
            %% Curate
            
            fprintf("\nThis neuron has the following modulation properties:\n")
            modulation = uiState.masks.modulation{uiState.channelIdx};
            modStr = sprintf ...
                ( "cs: %d\n" ...
                + "prior: %d\n" ...
                + "us: %d\n\n" ...
                , modulation.cs ...
                , modulation.prior ...
                , modulation.us ...
                );
            IkUtils.printIndented(modStr);
            
            fprintf("Original automated modulation estimate:\n")
            disp(modulationEstimate)

            [choice, choiceIdx] = IkUtils.do_prompt_select_option([choiceMap{:,1}]);
            
            stateUpdateFn = choiceMap{choiceIdx, 2};

            try
                uiState = stateUpdateFn(uiState, SessionConstants);
            catch err
                warning ...
                    ( "Caught error during execution of `%s`:\n%s\n" ...
                    + "\terror: %s\n" ...
                    + "\tfunction: %s\n" ...
                    + "\tline: %d\n" ...
                    , choice ...
                    , IkUtils.sprintImportant(string(err.message)) ...
                    , sprintf("%s: %s", err.identifier, err.message) ...
                    , err.stack(1).name ...
                    , err.stack(1).line ...
                    )

                fprintf("\nStarting debug mode.\n\n")
                keyboard
            end

        end
        
        if uiState.finishSession
            quit = true;
        end
        
        if uiState.reachedBottom
            warning("Already at first neuron of session")
            uiState.reachedBottom = false;
        end
        if uiState.reachedTop
            arrayfun ...
                ( @(ax) fadeAxes(ax, color = [0.7 0.7 0.7]) ...
                , axs.neuronAxs ...
                );
            quit = IkUtils.do_prompt_yes_or_no ...
                ( "Last neuron of Windowsession reached.\n" ...
                + "\n    Finish curating this session now?" ...
                );
            if ~quit
                uiState.reachedTop = false;
            end
        end
    
    
    end
    
    maskStruct = uiState.masks;
    
    function uiState = debug(uiState, ~)
        keyboard
    end

end

function uiState = finishSession(uiState, ~)
    
    uiState.finishSession = true;
    
end

function uiState = toggleExemplaryNeuron(uiState, ~)
    arguments
        uiState(1,1) UiState
        ~
    end
    
    idx = uiState.channelIdx;
    exemplaryStatus = uiState.masks.exemplary(idx);
    uiState.masks.exemplary(idx) = not(exemplaryStatus);
    
    if uiState.masks.exemplary(idx)
        uiState.masks.complex(idx) = true;
    end
    
end

function uiState = promptModulationMask(uiState, ~)
    
    modulationCombinations = ...
        { "none"            , [] ...
        ; "CS only"         , ["cs"] ...
        ; "Prior only"      , ["prior"] ...
        ; "US only"         , ["us"] ...
        ; "CS and Prior"    , ["cs", "prior"] ...
        ; "CS and US"       , ["cs", "us"] ...
        ; "Prior and US"    , ["prior", "us"] ...analyzedEphysFiles
        ; "All three"       , ["cs", "prior", "us"] ...
        };
    
    [~, idx] = IkUtils.do_prompt_select_option([modulationCombinations{:,1}]);
    
    newMask = modulationStruct(modulationCombinations{idx, 2});
    
    uiState.masks.modulation{uiState.channelIdx} = newMask;

    function result = modulationStruct(events)

        result = struct ...
            ( cs = false ...
            , prior = false ...
            , us = false ...
            );

        for event = events(:)'
            result.(event) = true;
        end

    end
    
end

function uiState = toggleComplex(uiState, ~)
    arguments
        uiState(1,1) UiState
        ~
    end

    idx = uiState.channelIdx;
    selectionStatus = uiState.masks.complex(idx);
    uiState.masks.complex(idx) = not(selectionStatus);
    
    if not(uiState.masks.complex(idx))
        uiState.masks.exemplary(idx) = false;
        uiState.masks.modulation{idx} = [];
    end
end

function uiState = saveFigure(uiState, constants)
    set(0, 'defaultFigureRenderer', 'painters');
    fig = constants.axs.neuronAx(1).Parent;
    folder = fullfile ...
        ( Env.getBayesLabUserRoot() ...
        , "TraceExperiments" ...
        , "ComplexSpikeToolkit" ...
        , "CSpk_Suite_revised" ...
        , "paperFigures" ...
        );
    
    file = sprintf ...
        ( "complexCuration_%s_S=%d_N=%d.eps" ...
        , constants.mname ...
        , constants.sessionIdx ...
        , constants.ksTrueId(uiState.channelIdx) ...
        );
    
    print(fig, '-depsc', '-painters', fullfile(folder, file))
end

%% Navigation Utilities

function bool = hasPrev(candidateMask, idx)
    bool = idx > find(candidateMask, 1);
end

function bool = hasNext(candidateMask, idx)    
   bool = idx < find(candidateMask, 1, 'last');
end

function fn = mkPrevFn(candidateMask)
    
    function uiState = prevChannel(uiState, ~)
        currentIdx = uiState.channelIdx;
        if hasPrev(candidateMask, currentIdx)
            prevIdx = find(candidateMask(1:(currentIdx-1)), 1, 'last');
        else
            prevIdx = currentIdx;
            uiState.reachedBottom = true;
        end
        uiState.channelIdx = prevIdx;
    end
    
    fn = @prevChannel;
end

function fn = mkNextFn(candidateMask)
    
    function uiState = nextChannel(uiState, ~)
        currentIdx = uiState.channelIdx;
        if hasNext(candidateMask, currentIdx)
            nextIdx = currentIdx + find(candidateMask(currentIdx+1:end, 1), 1);
        else
            nextIdx = currentIdx;
            uiState.reachedTop = true;
        end
        uiState.channelIdx = nextIdx;
    end
    
    fn = @nextChannel;
end