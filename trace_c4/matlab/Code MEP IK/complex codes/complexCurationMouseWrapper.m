% Curate complex channels of all sessions for the selected mouse

% Copyright 2023 NarainLab
% Erasmus Medical Center, Rotterdam, The Netherlands
% v2023-01-05
% 

% complexCurationMouseWrapper : SubjectID -> [CurationResult]
function masks = complexCurationMouseWrapper(mcode)
        
    if nargin < 1
        
        fprintf("\n-------------------------------------")
        fprintf("\nWhich mouse would you like to curate?")
        fprintf("\n-------------------------------------\n")

        mouseCodes = arrayfun ...
            ( @(mouse) string(mouse.code) ...
            , defaultMice() ...
            );
        mouseNames = arrayfun ...
            ( @(mouse) string(mouse.name) ...
            , defaultMice() ...
            );
        %mouseNames = [mouseNames, "All of the above"];

        
        mname_idx = do_prompt_select_option(mouseNames);
        mcode = mouseCodes(mname_idx);
        mname = mouseNames(mname_idx);
    end
    
%     spikeSortedEphysData = loadAnalyzedEphysDataForMouse(mname);
    spikeSortedEphysData = getData(mcode);
    
%     sessionIdcs = splitSessionsByType(mname);
    
%     allSessionIdcs = [sessionIdcs.delta sessionIdcs.uniform];
    
    nSessions = length(spikeSortedEphysData);
    
    candidateMasks = computeChannelCandidates(spikeSortedEphysData);

    simpleCuration = loadSimpleCurationResultSanitized(mcode);
    
    if numel(simpleCuration) ~= nSessions
        if numel(simpleCuration) > 0
            warning ...
                ( "No. sessions in simple curation result does not match the " ...
                + "no. sessions found for %s:\n" ...
                + "\tsimple curation: %d\n" ...
                + "\tcurrent: %d\n" ...
                , mcode ...
                , numel(simpleCuration) ...
                , nSessions ...
                )
            keyboard
        else
            fprintf("\nNo simple spike curation results found for %s.\n", mcode)
        end
    end
    
    getSimpleCuration = IkUtils.mkSafeArrayWrapper(simpleCuration, default = struct( simple = []));
    
    axs = struct ...
        ( neuronAxs = IkUtils.initPlots([2 3], condensed = true) ...
        , contaminAx = IkUtils.initPlots([1 1], condensed = true) ...
        , crossCorrAx = IkUtils.initPlots([1 1], condensed = true) ...
        );
    
    prevCuration = loadComplexCurationResultRaw(mcode, onlyLatest = true);
    
    getPrevCur = IkUtils.mkSafeArrayWrapper(prevCuration);
    
    if numel(prevCuration) ~= nSessions
        if numel(prevCuration) > 0
            warning ...
                ( "No. sessions in previous curation result does not match the " ...
                + "no. sessions found for %s:\n" ...
                + "\tprevious: %d\n" ...
                + "\tcurrent: %d\n" ...
                , mcode ...
                , numel(prevCuration) ...
                , nSessions ...
                )
            prevCuration = @(idx) getPrevCur(idx);
            keyboard
        else
            fprintf("\nNo previous curation results found for %s.\n", mcode)
            prevCuration = @(~) [];
        end
    end
        
    masks = arrayfun ...
        ( @(sessionIdx) ...
            complexCurationSessionWrapper ...
            ( axs ...
            , mcode ...
            , sessionIdx ...
            , spikeSortedEphysData(sessionIdx)...
            , candidateMasks(sessionIdx).complexMask ...
            , getSimpleCuration(sessionIdx).simple ...
            , getPrevCur(sessionIdx) ...
            ) ...
        , allSessionIdcs ...
        );
    
    saveComplexCurationResult(mcode, masks);%, struct(type = getMouseType(mname)) )
    
end
function choice = do_prompt_select_option(choices)
for i = 1:length(choices)
    fprintf("%d. %s\n", i, choices(i))
end
choice = input("");
end
