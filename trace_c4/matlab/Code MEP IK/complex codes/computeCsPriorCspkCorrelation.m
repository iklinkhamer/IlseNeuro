function computeCsPriorCspkCorrelation(kwargs)
    arguments
        kwargs.mouseNames (1,:) string = [paperFiguresMice().name];
        kwargs.type (1,1) string = "uniform";
    end
    
%     debugAx = IkUtils.initPlots();
    
    p = getParams();
    
    outputRoot = fullfile ...
        ( Env.getBayesLabUserRoot ...
        , "TraceExperiments" ...
        , "ComplexSpikeToolkit" ...
        , "CSpk_Suite_revised" ...
        , "paperFigures" ...
        , "cs_prior_cspk_correlation" ...
        , kwargs.type ...
        );
    
    if exist(outputRoot, 'dir') ~= 7
        mkdir(outputRoot)
    end
    
    mouseResults = IkUtils.flatmap ...
        ( @computeSingleMouse ...
        , kwargs.mouseNames ...
        , uniformoutput = true ...
        );
    
    keyboard
    
%     ax = IkUtils.initPlots;
    
    [allCsTimesCell, allPriorTimesCell, axsCell] = arrayfun ...
        ( @processMouseResult ...
        , mouseResults ...
        , uniformoutput = false ...
        );
    
    allCsTimes = IkUtils.flatten(allCsTimesCell, uniformoutput = true);
    allPriorTimes = IkUtils.flatten(allPriorTimesCell, uniformoutput = true);
    
    [rAll, pAll] = corrcoef(allCsTimes, allPriorTimes);
    allMiceAx = mkAx("all mice", rAll, pAll);
    plot(allMiceAx, allCsTimes, '*')
    
    printFigure ...
        ( allMiceAx.Parent ...
        , sprintf("cs_prior_corr_%s", "allMice") ...
        , folder = outputRoot ...
        )
    
    keyboard
    
    function ax = mkAx(mname, rVal, pVal)
        ax = IkUtils.initPlots();
        xlabel(ax, "cs cspk time [ms]")
        ylabel(ax, "prior cspk time [ms]")
        title ...
            ( sprintf ...
                ( "%s %s --- r: %.2f p: %.2f" ...
                , mname ...
                , kwargs.type ...
                , rVal(1,2) ...
                , pVal(1,2) ...
                ) ...
            )
    end
    
    function [allCsTimes, allPriorTimes, ax] = processMouseResult(mouseResult)

        sessionResults = mouseResult.sessionResults;
        
        allCsTimes = IkUtils.flatmap ...
            ( @(channel) channel.csSpikeTimes ...
            , [sessionResults.channelResults] ...
            );

        allPriorTimes = IkUtils.flatmap ...
            ( @(channel) channel.priorSpikeTimes ...
            , [sessionResults.channelResults] ...
            );
        
        [rVal,pVal] = corrcoef(allCsTimes, allPriorTimes);

        ax = mkAx(mouseResult.name, rVal, pVal);
        plot(ax, allCsTimes, allPriorTimes, '*')
        
        printFigure ...
            ( ax.Parent ...
            , sprintf("cs_prior_corr_%s", mouseResult.name) ...
            , folder = outputRoot ...
            )
        
    end
    
    function mouseResult = computeSingleMouse(mname)
    
        spikeData = loadAnalyzedEphysDataForMouse(mname);
    
        [curationResults, emptyMask] = loadComplexCurationResultSanitized(mname);

        sessionIdcs = splitSessionsByType(mname).(kwargs.type);
        
        if isempty(sessionIdcs)
            mouseResult = [];
            keyboard
            return
        end

        sessionsMask = not(emptyMask(sessionIdcs));
    %     keyboard

        sessionResultsCell = arrayfun ...
            ( @computeSingleSession ...
            , spikeData(sessionsMask) ...
            , curationResults(sessionsMask) ...
            , uniformoutput = false ...
            );
        
        nonEmptySessionsMask = cellfun ...
            ( @(x) not(isempty(x)) && not(isempty(x.channelResults)) ...
            , sessionResultsCell ...
            );
        
        if not(any(nonEmptySessionsMask))
            mouseResult = [];
            fprintf("Zero results for mouse %s\n", mname)
            keyboard
            return
        end

        sessionResults = cell2mat(sessionResultsCell(nonEmptySessionsMask));
        
        mouseResult = struct ...
            ( sessionResults = sessionResults ...
            , sessionIdcs = find(nonEmptySessionsMask)...
            , name = mname ...
            );

        rVals = arrayfun ...
            ( @(chanRes) chanRes.correlation.r ...
            , [mouseResult.sessionResults.channelResults] ...
            );
        pVals = arrayfun ...
            ( @(chanRes) chanRes.correlation.p ...
            , [mouseResult.sessionResults.channelResults] ...
            );

        negMask = rVals <= -.45;
        posMask = rVals >= .45;
        neutralMask = not(negMask | posMask);
        
        [ax, fig] = IkUtils.initPlots();
        histWrapper = @(vals, faceColor) ...
            histogram ...
                ( ax ...
                , vals ...
                , BinEdges = -1:.05:1 ...
                , facecolor = faceColor ...
                , edgecolor = 'none' ...
                );
        histWrapper(rVals(posMask), [.3 .8 .3])
        histWrapper(rVals(negMask), [.3 .8 .3])
        histWrapper(rVals(neutralMask), [.8 .8 .8])
        
        percFn = @(n) n / numel(rVals) * 100;
        title ...
            ( ax ...
            , sprintf ...
                ( "%s, N: %d, N^{-}: %d (%.1f%%), N^{+}: %d (%.1f%%)" ...
                , mname ...
                , numel(rVals) ...
                , sum(negMask), percFn(sum(negMask)) ...
                , sum(posMask), percFn(sum(posMask)) ...
                ) ...
            )
        
        keyboard
    end
    
    function sessionResult = computeSingleSession(sessionData, sessionCuration)
        
        if isempty(sessionCuration.complex)
            sessionResult = [];
            keyboard
            return
        end
       
%         keyboard

        complexMask = sessionCuration.complex;
        csModMask = sessionCuration.modulation.cs;
        priorModMask = sessionCuration.modulation.prior;
        
        channelMask = complexMask & csModMask & priorModMask;
        
        if isempty(channelMask)
            sessionResult = [];
            keyboard
            return
        end
        
        [channelResults, goodMask] = arrayfun ...
           ( @computeSingleChannel ...
           , sessionData.neuron(channelMask) ...
           );
       
       sessionResult = struct ...
           ( channelResults = channelResults(goodMask) ...
           , channelIdcs = find(channelMask(goodMask)) ...
           );
               
    end
    
    function [channelResult, ok] = computeSingleChannel(neuronData)
        
        spikeTimes = neuronData.RasterXY_cs(1,1:3:end);
        spikeTrials = neuronData.RasterXY_cs(2,1:3:end);
        
        allTrialIdcs = sort(unique(spikeTrials));
        
        [csTimesCell, priorTimesCell] = arrayfun ...
            ( @(trialIdx) computeSingleTrial(spikeTimes(spikeTrials == trialIdx)) ...
            , allTrialIdcs ...
            , uniformoutput = false ...
            );
        
        nonEmptyMask = cellfun ...
            ( @(csTimes, priorTimes) ...
                        not(isempty(csTimes)) && not(isempty(priorTimes)) ...
            , csTimesCell ...
            , priorTimesCell ...
            );
        
        [csTimes, priorTimes] = arrayfun ...
            ( @(trialId) deal(csTimesCell{trialId}(1), priorTimesCell{trialId}(1)) ...
            , find(nonEmptyMask) ...
            );

        fprintf("Trials with concomitant CS- and prior-related cspk: %d\n", sum(nonEmptyMask))

        [rMat, pMat] = corrcoef(csTimes, priorTimes);
        if sum(nonEmptyMask) < 2
            ok = false;
            rVal = nan;
            pVal = nan;
        else
            ok = true;
            rVal = rMat(1,2);
            pVal = pMat(1,2);
        end
        
%         if pVal < 0.05
%             cla(debugAx)
%             plot(debugAx, csTimes, priorTimes, '*')
%             title(debugAx, sprintf("r: %.2f, p: %.3f", rVal, pVal))
%             keyboard
%         end
        
        trialIdcs = allTrialIdcs(nonEmptyMask);
        
        channelResult = struct ...
            ( csSpikeTimes = csTimes ...
            , priorSpikeTimes = priorTimes ...
            , trialIdcs = trialIdcs ...
            , correlation = struct ...
                ( r = rVal ...
                , p = pVal ...
                ) ...
            );
                
    end
    
    function [csTimes, priorTimes] = computeSingleTrial(spikeTimes)
       
        csMin = p.cspkRanges.cs.min;
        csMax = p.cspkRanges.cs.max;
        priorMin = p.cspkRanges.prior.min;
        priorMax = p.cspkRanges.prior.max;
        
        csMask = spikeTimes >= csMin & spikeTimes < csMax;
        priorMask = spikeTimes >= priorMin & spikeTimes < priorMax;
        
        csTimes = spikeTimes(csMask) * 1000;
        priorTimes = spikeTimes(priorMask) * 1000;
        
    end
    
end